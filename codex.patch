diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
index 0000000..6a49457
--- /dev/null
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,46 @@
+name: CI
+
+on:
+  push:
+    branches: [main, feat/prototype-v2]
+  pull_request:
+
+jobs:
+  test:
+    runs-on: ubuntu-latest
+    timeout-minutes: 30
+
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Setup Node 20
+        uses: actions/setup-node@v4
+        with:
+          node-version: '20'
+          cache: 'npm'
+
+      - name: Print npm registry config
+        run: |
+          echo "npm registry: $(npm config get registry)"
+          if [ -f .npmrc ]; then
+            echo "Found .npmrc in repository root:"
+            cat .npmrc
+          else
+            echo "No repository .npmrc found."
+          fi
+
+      - name: Install dependencies
+        run: npm ci
+
+      - name: Build
+        run: npm run build
+
+      - name: Unit tests
+        run: npm test
+
+      - name: Install Playwright browsers
+        run: npx playwright install --with-deps chromium
+
+      - name: E2E tests
+        run: npm run test:e2e
diff --git a/.npmrc b/.npmrc
new file mode 100644
index 0000000..214c29d
--- /dev/null
+++ b/.npmrc
@@ -0,0 +1 @@
+registry=https://registry.npmjs.org/
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..a0275d0
--- /dev/null
+++ b/README.md
@@ -0,0 +1,45 @@
+# SOSG Running Club Hub prototype v2
+
+JSON-driven Next.js App Router prototype for SOSG running workflows.
+
+## Run
+
+```bash
+npm install
+npm run dev
+```
+
+Open `http://localhost:3000/login`.
+
+## Persistence
+
+Persistence is opt-in only and enabled with query param:
+
+- `http://localhost:3000/login?persist=1`
+
+When enabled, app state + mockData hydrates/saves from localStorage key `sosg-store-v1`.
+Without `persist=1`, the app never persists.
+
+## Architecture
+
+- `spec/appSpec.json`: source of truth for screens/routes/actions/templates.
+- `src/components/ScreenRenderer.tsx`: generic screen/component renderer and action engine.
+- `src/lib/store.ts`: Zustand store with `getByPath`, `setByPath`, `mutateMock` (`prepend`, `prependMany`).
+- `src/lib/path.ts`: required `buildPath(screenId, params)` helper based on spec route patterns.
+- `tests/unit/actions.spec.ts`: Jest unit coverage for core deterministic behavior.
+- `tests/e2e/sosg.spec.ts`: Playwright E2E for role gating, note flow, Strava flow, and empty state.
+
+
+## CI
+
+CI is source of truth since Codex env can‚Äôt reach npm registry.
+The GitHub Actions workflow runs `npm ci`, `npm run build`, `npm test`, and headless Playwright E2E (with browser installation).
+The CI workflow file is `.github/workflows/ci.yml` and runs on pull requests to validate this prototype.
+
+## Tests
+
+```bash
+npm run test
+npm run test:e2e
+npm run build
+```
diff --git a/jest.config.ts b/jest.config.ts
new file mode 100644
index 0000000..2e1d378
--- /dev/null
+++ b/jest.config.ts
@@ -0,0 +1,9 @@
+import type { Config } from 'jest';
+
+const config: Config = {
+  preset: 'ts-jest',
+  testEnvironment: 'jsdom',
+  testMatch: ['**/tests/unit/**/*.spec.ts']
+};
+
+export default config;
diff --git a/next-env.d.ts b/next-env.d.ts
new file mode 100644
index 0000000..84ab714
--- /dev/null
+++ b/next-env.d.ts
@@ -0,0 +1,4 @@
+/// <reference types="next" />
+/// <reference types="next/image-types/global" />
+
+// NOTE: This file should not be edited
diff --git a/next.config.mjs b/next.config.mjs
new file mode 100644
index 0000000..4678774
--- /dev/null
+++ b/next.config.mjs
@@ -0,0 +1,4 @@
+/** @type {import('next').NextConfig} */
+const nextConfig = {};
+
+export default nextConfig;
diff --git a/package-lock.json b/package-lock.json
new file mode 100644
index 0000000..86dd305
--- /dev/null
+++ b/package-lock.json
@@ -0,0 +1,30 @@
+{
+  "name": "runsosg",
+  "version": "0.1.0",
+  "lockfileVersion": 3,
+  "requires": true,
+  "packages": {
+    "": {
+      "name": "runsosg",
+      "version": "0.1.0",
+      "dependencies": {
+        "next": "14.2.32",
+        "react": "18.3.1",
+        "react-dom": "18.3.1",
+        "zustand": "4.5.5"
+      },
+      "devDependencies": {
+        "@playwright/test": "1.54.2",
+        "@testing-library/jest-dom": "6.6.3",
+        "@types/jest": "29.5.12",
+        "@types/node": "20.16.5",
+        "@types/react": "18.3.12",
+        "@types/react-dom": "18.3.1",
+        "jest": "29.7.0",
+        "jest-environment-jsdom": "29.7.0",
+        "ts-jest": "29.2.5",
+        "typescript": "5.6.2"
+      }
+    }
+  }
+}
diff --git a/package.json b/package.json
new file mode 100644
index 0000000..33a8aca
--- /dev/null
+++ b/package.json
@@ -0,0 +1,31 @@
+{
+  "name": "runsosg",
+  "version": "0.1.0",
+  "private": true,
+  "scripts": {
+    "dev": "next dev",
+    "build": "next build",
+    "start": "next start",
+    "lint": "next lint",
+    "test": "jest --runInBand",
+    "test:e2e": "playwright test"
+  },
+  "dependencies": {
+    "next": "14.2.32",
+    "react": "18.3.1",
+    "react-dom": "18.3.1",
+    "zustand": "4.5.5"
+  },
+  "devDependencies": {
+    "@playwright/test": "1.54.2",
+    "@testing-library/jest-dom": "6.6.3",
+    "@types/jest": "29.5.12",
+    "@types/node": "20.16.5",
+    "@types/react": "18.3.12",
+    "@types/react-dom": "18.3.1",
+    "jest": "29.7.0",
+    "jest-environment-jsdom": "29.7.0",
+    "ts-jest": "29.2.5",
+    "typescript": "5.6.2"
+  }
+}
diff --git a/playwright.config.ts b/playwright.config.ts
new file mode 100644
index 0000000..a04f539
--- /dev/null
+++ b/playwright.config.ts
@@ -0,0 +1,7 @@
+import { defineConfig } from '@playwright/test';
+
+export default defineConfig({
+  testDir: './tests/e2e',
+  use: { baseURL: 'http://127.0.0.1:3000', headless: true },
+  webServer: { command: 'npm run dev', port: 3000, timeout: 120000 }
+});
diff --git a/spec/appSpec.json b/spec/appSpec.json
new file mode 100644
index 0000000..639f2f7
--- /dev/null
+++ b/spec/appSpec.json
@@ -0,0 +1,388 @@
+{
+  "app": {
+    "name": "SOSG Running Club Hub",
+    "platform": "mobile_web_pwa",
+    "design": {
+      "layout": "mobile_first",
+      "navigation": "bottom_tabs",
+      "tone": "calm_supportive_non_competitive",
+      "privacyDefault": "strict"
+    },
+    "roles": ["PARENT", "VOLUNTEER", "COACH", "ADMIN"]
+  },
+  "state": {
+    "role": "VOLUNTEER",
+    "authed": false,
+    "linkedStrava": false,
+    "strava": {
+      "accessTokenPresent": false,
+      "lastImportAt": null,
+      "importRules": {
+        "mode": "TAG",
+        "tag": "#sosg",
+        "timeWindowMinutes": 240
+      }
+    }
+  },
+  "routes": {
+    "initial": "login",
+    "tabs": [
+      { "id": "tab_timeline", "label": "Timeline", "icon": "üèÉ", "route": "athlete_list" },
+      { "id": "tab_athletes", "label": "Athletes", "icon": "üë•", "route": "athlete_list" },
+      { "id": "tab_profile", "label": "Profile", "icon": "‚öôÔ∏è", "route": "profile" }
+    ]
+  },
+  "screens": [
+    {
+      "id": "login",
+      "title": "SOSG Running Club",
+      "route": "login",
+      "layout": { "type": "centered" },
+      "components": [
+        { "type": "image", "id": "logo", "props": { "alt": "SOSG Logo", "placeholder": true } },
+        { "type": "textInput", "id": "email", "props": { "label": "Email", "placeholder": "name@example.com" } },
+        { "type": "passwordInput", "id": "password", "props": { "label": "Password" } },
+        {
+          "type": "select",
+          "id": "role_selector",
+          "props": { "label": "Role (prototype)", "options": ["PARENT", "VOLUNTEER", "COACH", "ADMIN"], "default": "VOLUNTEER" },
+          "actions": [{ "type": "setState", "path": "state.role", "value": "{{value}}" }]
+        },
+        {
+          "type": "button",
+          "id": "btn_login",
+          "props": { "label": "Login" },
+          "actions": [
+            { "type": "setState", "path": "state.authed", "value": true },
+            { "type": "navigate", "to": "athlete_list" }
+          ]
+        }
+      ]
+    },
+
+    {
+      "id": "athlete_list",
+      "title": "Athletes",
+      "route": "athlete_list",
+      "layout": { "type": "list" },
+      "components": [
+        { "type": "searchBar", "id": "athlete_search", "props": { "placeholder": "Search athlete..." } },
+        {
+          "type": "list",
+          "id": "athlete_cards",
+          "props": { "itemTemplate": "athleteCard" },
+          "dataBinding": "mockData.athletes",
+          "actions": [{ "type": "navigate", "to": "athlete_timeline", "with": { "athleteId": "{{item.id}}" } }]
+        }
+      ]
+    },
+
+    {
+      "id": "athlete_timeline",
+      "title": "Athlete Timeline",
+      "route": "athlete_timeline/:athleteId",
+      "layout": { "type": "stack" },
+      "onEnter": [
+        { "type": "selectAthleteByRouteParam", "param": "athleteId", "from": "mockData.athletesFull", "target": "mockData.selectedAthlete" }
+      ],
+      "components": [
+        {
+          "type": "header",
+          "id": "hdr_athlete",
+          "props": {
+            "leftAction": { "type": "navigate", "to": "athlete_list" },
+            "titleBinding": "mockData.selectedAthlete.name",
+            "rightIcon": "‚öôÔ∏è"
+          },
+          "actions": [{ "type": "navigate", "to": "athlete_settings", "with": { "athleteId": "{{route.athleteId}}" } }]
+        },
+
+        {
+          "type": "card",
+          "id": "card_cues_pinned",
+          "props": { "title": "What works (pinned)", "collapsible": true, "defaultCollapsed": false },
+          "dataBinding": "mockData.selectedAthlete.cues",
+          "components": [
+            { "type": "kvList", "id": "cues_list", "props": { "items": [
+              { "k": "Helps", "v": "{{data.helps}}" },
+              { "k": "Avoid", "v": "{{data.avoids}}" },
+              { "k": "Best cues", "v": "{{data.bestCues}}" },
+              { "k": "Kit", "v": "{{data.kit}}" }
+            ]}}
+          ],
+          "footerActions": [
+            {
+              "type": "button",
+              "id": "btn_edit_cues",
+              "visibility": { "roles": ["VOLUNTEER", "COACH", "ADMIN"] },
+              "props": { "label": "Edit cues" },
+              "actions": [{ "type": "navigate", "to": "edit_cues", "with": { "athleteId": "{{route.athleteId}}" } }]
+            }
+          ]
+        },
+
+        { "type": "segmentedControl", "id": "timeline_filter", "props": { "options": ["All", "Sessions", "Notes", "Milestones", "Photos"], "default": "All" } },
+
+        {
+          "type": "list",
+          "id": "timeline_feed",
+          "props": { "itemTemplate": "timelineCard" },
+          "dataBinding": "mockData.selectedAthlete.timeline",
+          "filterBinding": { "controlId": "timeline_filter", "map": { "All": "*", "Sessions": "session", "Notes": "note", "Milestones": "milestone", "Photos": "photo" } },
+          "emptyState": { "title": "No entries yet", "message": "Add a coach note or a first session to start the athlete‚Äôs journey." }
+        },
+
+        {
+          "type": "actionBar",
+          "id": "timeline_actions",
+          "props": { "style": "sticky_bottom" },
+          "components": [
+            {
+              "type": "button",
+              "id": "btn_add_note",
+              "visibility": { "roles": ["VOLUNTEER", "COACH", "ADMIN"] },
+              "props": { "label": "Add Note" },
+              "actions": [{ "type": "navigate", "to": "add_coach_note", "with": { "athleteId": "{{route.athleteId}}" } }]
+            },
+            {
+              "type": "button",
+              "id": "btn_add_session",
+              "visibility": { "roles": ["VOLUNTEER", "COACH", "ADMIN"] },
+              "props": { "label": "Add Session" },
+              "actions": [{ "type": "navigate", "to": "add_session", "with": { "athleteId": "{{route.athleteId}}" } }]
+            },
+            {
+              "type": "button",
+              "id": "btn_import_strava",
+              "visibility": { "roles": ["VOLUNTEER", "COACH", "ADMIN"] },
+              "props": { "label": "Import Strava" },
+              "actions": [
+                { "type": "conditionalNavigate", "if": "state.strava.accessTokenPresent", "to": "strava_import_review", "elseTo": "strava_connect", "with": { "athleteId": "{{route.athleteId}}" } }
+              ]
+            }
+          ]
+        }
+      ]
+    },
+
+    {
+      "id": "athlete_settings",
+      "title": "Athlete Settings",
+      "route": "athlete_settings/:athleteId",
+      "layout": { "type": "stack" },
+      "components": [
+        { "type": "sectionTitle", "id": "sec_privacy", "props": { "text": "Privacy & Consent" } },
+        { "type": "toggle", "id": "consent_photos", "props": { "label": "Allow photos in timeline", "default": false } },
+        { "type": "toggle", "id": "consent_location", "props": { "label": "Show route/maps to coaches", "default": false } },
+        { "type": "divider", "id": "div1" },
+        { "type": "sectionTitle", "id": "sec_strava", "props": { "text": "Strava" } },
+        {
+          "type": "button",
+          "id": "btn_strava_connect",
+          "props": { "label": "Connect Strava" },
+          "actions": [{ "type": "navigate", "to": "strava_connect", "with": { "athleteId": "{{route.athleteId}}" } }]
+        }
+      ]
+    },
+
+    {
+      "id": "strava_connect",
+      "title": "Connect Strava",
+      "route": "strava_connect/:athleteId",
+      "layout": { "type": "stack" },
+      "components": [
+        { "type": "text", "id": "strava_info", "props": { "text": "Connect a Strava account to import runs. In production, this uses OAuth. In prototype, simulate connect." } },
+        {
+          "type": "button",
+          "id": "btn_simulate_strava_connect",
+          "props": { "label": "Simulate Strava Connect" },
+          "actions": [
+            { "type": "setState", "path": "state.strava.accessTokenPresent", "value": true },
+            { "type": "toast", "message": "Strava connected (prototype)." },
+            { "type": "navigate", "to": "strava_import_review", "with": { "athleteId": "{{route.athleteId}}" } }
+          ]
+        }
+      ]
+    },
+
+    {
+      "id": "strava_import_review",
+      "title": "Import from Strava",
+      "route": "strava_import_review/:athleteId",
+      "layout": { "type": "stack" },
+      "components": [
+        { "type": "text", "id": "rules_title", "props": { "text": "Import rules (prototype)" } },
+        {
+          "type": "select",
+          "id": "import_mode",
+          "props": { "label": "Mode", "options": ["TAG", "TIME_WINDOW"], "default": "TAG" },
+          "actions": [{ "type": "setState", "path": "state.strava.importRules.mode", "value": "{{value}}" }]
+        },
+        { "type": "textInput", "id": "tag", "props": { "label": "Tag (if TAG mode)", "placeholder": "#sosg" } },
+        { "type": "numberInput", "id": "time_window", "props": { "label": "Time window minutes (if TIME_WINDOW)", "step": 15 } },
+        { "type": "divider", "id": "div2" },
+        {
+          "type": "list",
+          "id": "candidate_activities",
+          "props": { "itemTemplate": "stravaCandidateCard" },
+          "dataBinding": "mockData.stravaCandidates"
+        },
+        {
+          "type": "button",
+          "id": "btn_import_selected",
+          "props": { "label": "Import selected" },
+          "actions": [
+            { "type": "mutateMock", "target": "mockData.selectedAthlete.timeline", "operation": "prependMany", "valueBinding": "mockData.stravaCandidatesSelectedAsTimelineEvents" },
+            { "type": "setState", "path": "state.strava.lastImportAt", "value": "NOW" },
+            { "type": "toast", "message": "Imported (prototype)." },
+            { "type": "navigate", "to": "athlete_timeline", "with": { "athleteId": "{{route.athleteId}}" } }
+          ]
+        }
+      ]
+    },
+
+    {
+      "id": "add_coach_note",
+      "title": "Add Coach Note",
+      "route": "add_coach_note/:athleteId",
+      "layout": { "type": "form" },
+      "visibility": { "roles": ["VOLUNTEER", "COACH", "ADMIN"] },
+      "components": [
+        { "type": "emojiPicker", "id": "mood_before", "props": { "label": "Mood before" } },
+        { "type": "emojiPicker", "id": "mood_after", "props": { "label": "Mood after" } },
+        { "type": "textArea", "id": "went_well", "props": { "label": "What went well", "maxChars": 120 } },
+        { "type": "textArea", "id": "was_hard", "props": { "label": "What was hard", "maxChars": 120 } },
+        { "type": "textArea", "id": "next_time", "props": { "label": "Next time: do / avoid", "maxChars": 120 } },
+        {
+          "type": "button",
+          "id": "btn_save_note",
+          "props": { "label": "Save Note" },
+          "actions": [
+            { "type": "mutateMock", "target": "mockData.selectedAthlete.timeline", "operation": "prepend", "valueTemplate": "mockTemplates.newNote" },
+            { "type": "navigate", "to": "athlete_timeline", "with": { "athleteId": "{{route.athleteId}}" } }
+          ]
+        }
+      ]
+    },
+
+    {
+      "id": "edit_cues",
+      "title": "Edit What Works",
+      "route": "edit_cues/:athleteId",
+      "layout": { "type": "form" },
+      "visibility": { "roles": ["VOLUNTEER", "COACH", "ADMIN"] },
+      "components": [
+        { "type": "chipInput", "id": "helps", "props": { "label": "Helps (add multiple)" } },
+        { "type": "chipInput", "id": "avoids", "props": { "label": "Avoid (add multiple)" } },
+        { "type": "chipInput", "id": "bestCues", "props": { "label": "Best cues (add multiple)" } },
+        { "type": "chipInput", "id": "kit", "props": { "label": "Kit (add multiple)" } },
+        {
+          "type": "button",
+          "id": "btn_save_cues",
+          "props": { "label": "Save" },
+          "actions": [
+            { "type": "toast", "message": "Cues saved (prototype)." },
+            { "type": "navigate", "to": "athlete_timeline", "with": { "athleteId": "{{route.athleteId}}" } }
+          ]
+        }
+      ]
+    },
+
+    {
+      "id": "add_session",
+      "title": "Add Session",
+      "route": "add_session/:athleteId",
+      "layout": { "type": "form" },
+      "visibility": { "roles": ["VOLUNTEER", "COACH", "ADMIN"] },
+      "components": [
+        { "type": "dateTimePicker", "id": "session_time", "props": { "label": "Date & time" } },
+        { "type": "numberInput", "id": "distance_km", "props": { "label": "Distance (km)", "step": 0.1 } },
+        { "type": "numberInput", "id": "moving_minutes", "props": { "label": "Moving time (min)", "step": 1 } },
+        { "type": "select", "id": "effort", "props": { "label": "Effort", "options": ["Easy", "OK", "Hard"], "default": "OK" } },
+        {
+          "type": "button",
+          "id": "btn_save_session",
+          "props": { "label": "Save Session" },
+          "actions": [
+            { "type": "mutateMock", "target": "mockData.selectedAthlete.timeline", "operation": "prepend", "valueTemplate": "mockTemplates.newSessionManual" },
+            { "type": "navigate", "to": "athlete_timeline", "with": { "athleteId": "{{route.athleteId}}" } }
+          ]
+        }
+      ]
+    },
+
+    {
+      "id": "profile",
+      "title": "Profile",
+      "route": "profile",
+      "layout": { "type": "stack" },
+      "components": [
+        { "type": "avatar", "id": "user_avatar", "props": { "placeholder": true } },
+        { "type": "kvList", "id": "user_info", "props": { "items": [
+          { "k": "Name", "v": "Prototype User" },
+          { "k": "Role", "v": "{{state.role}}" }
+        ]}},
+        {
+          "type": "button",
+          "id": "btn_logout",
+          "props": { "label": "Logout" },
+          "actions": [
+            { "type": "setState", "path": "state.authed", "value": false },
+            { "type": "navigate", "to": "login" }
+          ]
+        }
+      ]
+    }
+  ],
+  "templates": {
+    "athleteCard": { "type": "card", "title": "{{item.name}}", "subtitle": "Latest: {{item.latestMilestone}}", "rightMeta": "{{item.lastSeen}}" },
+    "timelineCard": { "type": "card", "title": "{{item.icon}} {{item.title}}", "subtitle": "{{item.subtitle}}", "body": "{{item.body}}", "meta": "{{item.date}}" },
+    "stravaCandidateCard": { "type": "card", "title": "üèÉ {{item.name}}", "subtitle": "{{item.distanceKm}} km ‚Ä¢ {{item.movingMin}} min ‚Ä¢ {{item.date}}", "body": "Tag: {{item.tag}} ‚Ä¢ Source: Strava", "meta": "{{item.id}}" }
+  },
+  "mockData": {
+    "athletes": [
+      { "id": "a1", "name": "Daniel", "latestMilestone": "5 sessions completed", "lastSeen": "2 days ago" },
+      { "id": "a2", "name": "Ayesha", "latestMilestone": "First continuous 1km", "lastSeen": "1 week ago" }
+    ],
+    "athletesFull": [
+      {
+        "id": "a1",
+        "name": "Daniel",
+        "cues": {
+          "helps": "Countdown cues, run/walk 2/1, consistent route",
+          "avoids": "Sudden loud noises, mid-run route changes",
+          "bestCues": "‚Äú2 more lamp posts‚Äù, ‚Äústeady breathing‚Äù",
+          "kit": "Water at 15 min, cap"
+        },
+        "timeline": [
+          { "type": "session", "source": "STRAVA", "icon": "üèÉ", "title": "Session", "subtitle": "2.3 km ‚Ä¢ 24 min ‚Ä¢ Effort: OK", "body": "Imported from Strava (tag #sosg).", "date": "Sat 10:10" },
+          { "type": "note", "icon": "üìù", "title": "Coach note", "subtitle": "Mood üòê ‚Üí üòä", "body": "Went well: steady pace. Hard: tired at 20 min. Next: water at 15.", "date": "Sat 10:35" },
+          { "type": "milestone", "icon": "üéâ", "title": "Milestone", "subtitle": "5 sessions completed", "body": "Consistency win ‚Äî keep it going.", "date": "Sat 10:36" }
+        ]
+      },
+      {
+        "id": "a2",
+        "name": "Ayesha",
+        "cues": { "helps": "Short cues, predictable stops", "avoids": "Crowded paths", "bestCues": "‚ÄúOne more minute‚Äù", "kit": "Water, sunglasses" },
+        "timeline": []
+      }
+    ],
+    "selectedAthlete": {
+      "id": "a1",
+      "name": "Daniel",
+      "cues": { "helps": "", "avoids": "", "bestCues": "", "kit": "" },
+      "timeline": []
+    },
+    "stravaCandidates": [
+      { "id": "s101", "name": "Morning Run", "distanceKm": 2.1, "movingMin": 22, "date": "Sun 09:15", "tag": "#sosg" },
+      { "id": "s102", "name": "Park Jog", "distanceKm": 3.0, "movingMin": 31, "date": "Wed 18:40", "tag": "" }
+    ],
+    "stravaCandidatesSelectedAsTimelineEvents": [
+      { "type": "session", "source": "STRAVA", "icon": "üèÉ", "title": "Session", "subtitle": "2.1 km ‚Ä¢ 22 min ‚Ä¢ Effort: OK", "body": "Imported from Strava.", "date": "Just now" }
+    ]
+  },
+  "mockTemplates": {
+    "newNote": { "type": "note", "icon": "üìù", "title": "Coach note", "subtitle": "Mood üòä ‚Üí üòä", "body": "Went well: (from form). Hard: (from form). Next: (from form).", "date": "Just now" },
+    "newSessionManual": { "type": "session", "source": "MANUAL", "icon": "üèÉ", "title": "Session", "subtitle": "(from form) km ‚Ä¢ (from form) min ‚Ä¢ Effort: (from form)", "body": "Added manually.", "date": "Just now" }
+  }
+}
diff --git a/src/app/add_coach_note/[athleteId]/page.tsx b/src/app/add_coach_note/[athleteId]/page.tsx
new file mode 100644
index 0000000..07048a8
--- /dev/null
+++ b/src/app/add_coach_note/[athleteId]/page.tsx
@@ -0,0 +1,2 @@
+import SpecGate from '@/components/SpecGate';
+export default function Page({ params }: { params: { athleteId: string } }) { return <SpecGate screenId='add_coach_note' routeParams={params} />; }
diff --git a/src/app/add_session/[athleteId]/page.tsx b/src/app/add_session/[athleteId]/page.tsx
new file mode 100644
index 0000000..9036a28
--- /dev/null
+++ b/src/app/add_session/[athleteId]/page.tsx
@@ -0,0 +1,2 @@
+import SpecGate from '@/components/SpecGate';
+export default function Page({ params }: { params: { athleteId: string } }) { return <SpecGate screenId='add_session' routeParams={params} />; }
diff --git a/src/app/athlete_list/page.tsx b/src/app/athlete_list/page.tsx
new file mode 100644
index 0000000..64660ce
--- /dev/null
+++ b/src/app/athlete_list/page.tsx
@@ -0,0 +1,2 @@
+import SpecGate from '@/components/SpecGate';
+export default function Page(){ return <SpecGate screenId='athlete_list' />; }
diff --git a/src/app/athlete_settings/[athleteId]/page.tsx b/src/app/athlete_settings/[athleteId]/page.tsx
new file mode 100644
index 0000000..f406205
--- /dev/null
+++ b/src/app/athlete_settings/[athleteId]/page.tsx
@@ -0,0 +1,2 @@
+import SpecGate from '@/components/SpecGate';
+export default function Page({ params }: { params: { athleteId: string } }) { return <SpecGate screenId='athlete_settings' routeParams={params} />; }
diff --git a/src/app/athlete_timeline/[athleteId]/page.tsx b/src/app/athlete_timeline/[athleteId]/page.tsx
new file mode 100644
index 0000000..c57b9f3
--- /dev/null
+++ b/src/app/athlete_timeline/[athleteId]/page.tsx
@@ -0,0 +1,2 @@
+import SpecGate from '@/components/SpecGate';
+export default function Page({ params }: { params: { athleteId: string } }) { return <SpecGate screenId='athlete_timeline' routeParams={params} />; }
diff --git a/src/app/edit_cues/[athleteId]/page.tsx b/src/app/edit_cues/[athleteId]/page.tsx
new file mode 100644
index 0000000..1c3dba6
--- /dev/null
+++ b/src/app/edit_cues/[athleteId]/page.tsx
@@ -0,0 +1,2 @@
+import SpecGate from '@/components/SpecGate';
+export default function Page({ params }: { params: { athleteId: string } }) { return <SpecGate screenId='edit_cues' routeParams={params} />; }
diff --git a/src/app/globals.css b/src/app/globals.css
new file mode 100644
index 0000000..3983db4
--- /dev/null
+++ b/src/app/globals.css
@@ -0,0 +1,8 @@
+@import '../styles/tokens.css';
+*{box-sizing:border-box} body{margin:0;font-family:var(--font-sans);background:var(--bg);color:var(--text)}
+.page{max-width:480px;margin:0 auto;padding:var(--space-4);display:flex;flex-direction:column;gap:var(--space-3)}
+.card{background:var(--surface);border:var(--border);border-radius:var(--radius-md);box-shadow:var(--shadow-sm);padding:var(--space-4);display:flex;flex-direction:column;gap:var(--space-2)}
+button,input,select,textarea{min-height:44px;border:var(--border);border-radius:var(--radius-sm);padding:var(--space-2)}
+button{background:var(--accent);color:var(--accent-contrast)}
+.chip{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--border-color);font-size:var(--text-meta);width:fit-content}
+.chip-accent{border-color:var(--accent);color:var(--accent)}
diff --git a/src/app/layout.tsx b/src/app/layout.tsx
new file mode 100644
index 0000000..bf1b73e
--- /dev/null
+++ b/src/app/layout.tsx
@@ -0,0 +1,7 @@
+import './globals.css';
+
+export const metadata = { title: 'SOSG Running Club Hub' };
+
+export default function RootLayout({ children }: { children: React.ReactNode }) {
+  return <html lang="en"><body>{children}</body></html>;
+}
diff --git a/src/app/login/page.tsx b/src/app/login/page.tsx
new file mode 100644
index 0000000..403135e
--- /dev/null
+++ b/src/app/login/page.tsx
@@ -0,0 +1,2 @@
+import SpecGate from '@/components/SpecGate';
+export default function Page(){ return <SpecGate screenId='login' />; }
diff --git a/src/app/page.tsx b/src/app/page.tsx
new file mode 100644
index 0000000..b1996e9
--- /dev/null
+++ b/src/app/page.tsx
@@ -0,0 +1,2 @@
+import { redirect } from 'next/navigation';
+export default function Home() { redirect('/login'); }
diff --git a/src/app/profile/page.tsx b/src/app/profile/page.tsx
new file mode 100644
index 0000000..2f99d56
--- /dev/null
+++ b/src/app/profile/page.tsx
@@ -0,0 +1,2 @@
+import SpecGate from '@/components/SpecGate';
+export default function Page(){ return <SpecGate screenId='profile' />; }
diff --git a/src/app/strava_connect/[athleteId]/page.tsx b/src/app/strava_connect/[athleteId]/page.tsx
new file mode 100644
index 0000000..8ff316f
--- /dev/null
+++ b/src/app/strava_connect/[athleteId]/page.tsx
@@ -0,0 +1,2 @@
+import SpecGate from '@/components/SpecGate';
+export default function Page({ params }: { params: { athleteId: string } }) { return <SpecGate screenId='strava_connect' routeParams={params} />; }
diff --git a/src/app/strava_import_review/[athleteId]/page.tsx b/src/app/strava_import_review/[athleteId]/page.tsx
new file mode 100644
index 0000000..4def3a9
--- /dev/null
+++ b/src/app/strava_import_review/[athleteId]/page.tsx
@@ -0,0 +1,2 @@
+import SpecGate from '@/components/SpecGate';
+export default function Page({ params }: { params: { athleteId: string } }) { return <SpecGate screenId='strava_import_review' routeParams={params} />; }
diff --git a/src/components/ScreenRenderer.tsx b/src/components/ScreenRenderer.tsx
new file mode 100644
index 0000000..cef7f19
--- /dev/null
+++ b/src/components/ScreenRenderer.tsx
@@ -0,0 +1,141 @@
+'use client';
+
+import Link from 'next/link';
+import { useRouter } from 'next/navigation';
+import { useEffect, useMemo } from 'react';
+import { appSpec } from '@/lib/spec';
+import { interpolate } from '@/lib/interpolate';
+import { buildPath } from '@/lib/path';
+import { getValueByPath } from '@/lib/paths';
+import { useAppStore } from '@/lib/store';
+
+function isVisible(visibility: any, role: string) {
+  if (!visibility?.roles) return true;
+  return visibility.roles.includes(role);
+}
+
+export function runAction(action: any, ctx: any) {
+  const { store, routeParams, router } = ctx;
+  if (action.type === 'setState') store.setByPath(action.path, interpolate(action.value, ctx));
+  if (action.type === 'navigate') {
+    const params = Object.fromEntries(Object.entries(action.with || {}).map(([k, v]) => [k, interpolate(v, ctx)]));
+    router.push(buildPath(action.to, params));
+  }
+  if (action.type === 'conditionalNavigate') {
+    const cond = !!store.getByPath(action.if);
+    const params = Object.fromEntries(Object.entries(action.with || {}).map(([k, v]) => [k, interpolate(v, ctx)]));
+    router.push(buildPath(cond ? action.to : action.elseTo, params as Record<string, string>));
+  }
+  if (action.type === 'selectAthleteByRouteParam') {
+    const from = store.getByPath(action.from) || [];
+    const id = routeParams[action.param];
+    const selected = from.find((x: any) => x.id === id);
+    if (selected) store.setByPath(action.target, selected);
+  }
+  if (action.type === 'mutateMock') {
+    if (action.valueBinding) store.mutateMock(action.target, action.operation, store.getByPath(action.valueBinding));
+    if (action.valueTemplate) {
+      const tpl = structuredClone(store.getByPath(action.valueTemplate));
+      if (tpl.type === 'note') tpl.body = `Went well: ${store.getByPath('form.went_well') || '(from form)'}. Hard: ${store.getByPath('form.was_hard') || '(from form)'}. Next: ${store.getByPath('form.next_time') || '(from form)'}.`;
+      store.mutateMock(action.target, action.operation, tpl);
+    }
+  }
+}
+
+export default function ScreenRenderer({ screenId, routeParams }: { screenId: string; routeParams: Record<string, string> }) {
+  const screen = useMemo(() => appSpec.screens.find((s) => s.id === screenId), [screenId]);
+  const router = useRouter();
+  const store = useAppStore();
+
+  useEffect(() => {
+    store.initPersistence();
+  }, [store]);
+
+  useEffect(() => {
+    if (store.state.authed === false && screenId !== 'login') router.replace('/login');
+  }, [store.state.authed, screenId, router]);
+
+  useEffect(() => {
+    screen?.onEnter?.forEach((action) => runAction(action, { store, routeParams, route: routeParams, router }));
+  }, [screen, routeParams, store, router]);
+
+  if (!screen) return <div>Screen missing: {screenId}</div>;
+  if (!isVisible(screen.visibility, store.state.role)) {
+    return <div data-testid={`screen-${screen.id}`}><p>Access denied</p><Link href="/athlete_list">Go to athlete list</Link></div>;
+  }
+
+  const ctxBase = { store, routeParams, route: routeParams, state: store.state, data: null, router };
+
+  return (
+    <main className="page" data-testid={`screen-${screen.id}`}>
+      <h1>{screen.title}</h1>
+      {screen.components.map((c) => {
+        if (!isVisible(c.visibility, store.state.role)) return null;
+        return <ComponentRenderer key={c.id} component={c} ctx={ctxBase} />;
+      })}
+    </main>
+  );
+}
+
+function ComponentRenderer({ component, ctx, item, index }: any) {
+  const store = ctx.store;
+  const role = store.state.role;
+  if (!isVisible(component.visibility, role)) return null;
+  const run = (actions: any[] = [], extra: any = {}) => actions.forEach((a) => runAction(a, { ...ctx, ...extra, item }));
+  const id = component.id;
+
+  if (component.type === 'text') return <p>{interpolate(component.props?.text, { ...ctx, item })}</p>;
+  if (component.type === 'divider') return <hr />;
+  if (component.type === 'image' || component.type === 'avatar') return <div className="card">{component.props?.alt || 'Avatar'}</div>;
+  if (component.type === 'sectionTitle') return <h2>{component.props?.text}</h2>;
+  if (component.type === 'searchBar') return <input placeholder={component.props?.placeholder} />;
+  if (component.type === 'header') return <div className="card"><button onClick={() => run([component.props.leftAction])}>Back</button><strong>{store.getByPath(component.props.titleBinding)}</strong><button onClick={() => run(component.actions)}>{component.props.rightIcon}</button></div>;
+  if (component.type === 'kvList') return <dl>{component.props.items.map((kv: any) => <div key={kv.k}><dt>{kv.k}</dt><dd>{interpolate(kv.v, { ...ctx, data: ctx.data, item })}</dd></div>)}</dl>;
+  if (component.type === 'toggle') return <label><input data-testid={`toggle-${id}`} type="checkbox" defaultChecked={component.props?.default} />{component.props?.label}</label>;
+
+  if (component.type === 'button') return <button data-testid={`btn-${id}`} onClick={() => run(component.actions)}>{component.props?.label}</button>;
+
+  if (['textInput', 'passwordInput', 'numberInput', 'textArea', 'dateTimePicker', 'chipInput', 'emojiPicker'].includes(component.type)) {
+    const Tag = component.type === 'textArea' ? 'textarea' : 'input';
+    return <label>{component.props?.label}<Tag data-testid={`input-${id}`} type={component.type === 'passwordInput' ? 'password' : component.type === 'numberInput' ? 'number' : component.type === 'dateTimePicker' ? 'datetime-local' : 'text'} placeholder={component.props?.placeholder} onChange={(e: any) => store.setFormValue(id, e.target.value)} /></label>;
+  }
+
+  if (component.type === 'select') {
+    return <label>{component.props?.label}<select data-testid={`select-${id}`} defaultValue={component.props?.default} onChange={(e) => { store.setFormValue(id, e.target.value); run(component.actions, { value: e.target.value }); }}>{component.props.options.map((o: string) => <option key={o} value={o}>{o}</option>)}</select></label>;
+  }
+
+  if (component.type === 'segmentedControl') {
+    const value = store.controls[id] || component.props.default;
+    return <div>{component.props.options.map((o: string) => <button key={o} type="button" onClick={() => store.setControl(id, o)}>{o === value ? `‚Ä¢ ${o}` : o}</button>)}</div>;
+  }
+
+  if (component.type === 'card') {
+    const data = component.dataBinding ? store.getByPath(component.dataBinding) : null;
+    return <section className="card" data-testid={`card-${id}`}><h3>{component.props?.title}</h3>{component.components?.map((child: any) => <ComponentRenderer key={child.id} component={child} ctx={{ ...ctx, data }} />)}{component.footerActions?.map((b: any) => <ComponentRenderer key={b.id} component={b} ctx={ctx} />)}</section>;
+  }
+
+  if (component.type === 'actionBar') return <div className="card">{component.components.map((child: any) => <ComponentRenderer key={child.id} component={child} ctx={ctx} />)}</div>;
+
+  if (component.type === 'list') {
+    let items = store.getByPath(component.dataBinding) || [];
+    if (component.filterBinding) {
+      const selected = store.controls[component.filterBinding.controlId] || 'All';
+      const mapped = component.filterBinding.map[selected];
+      if (mapped && mapped !== '*') items = items.filter((x: any) => x.type === mapped);
+    }
+    if (!items.length && component.emptyState) return <div data-testid={`list-${id}`}><strong>{component.emptyState.title}</strong><p>{component.emptyState.message}</p></div>;
+    return <div data-testid={`list-${id}`}>{items.map((it: any, idx: number) => {
+      if (component.props?.itemTemplate === 'athleteCard') return <button className="card" key={it.id} data-testid={`athlete-card-${it.id}`} onClick={() => run(component.actions, { item: it })}><strong>{interpolate(appSpec.templates.athleteCard.title, { ...ctx, item: it })}</strong><span>{interpolate(appSpec.templates.athleteCard.subtitle, { ...ctx, item: it })}</span></button>;
+      if (component.props?.itemTemplate === 'timelineCard') return <article className="card" key={idx} data-testid={`timeline-item-${idx}`}><strong>{interpolate(appSpec.templates.timelineCard.title, { ...ctx, item: it })}</strong><p>{interpolate(appSpec.templates.timelineCard.subtitle, { ...ctx, item: it })}</p>{it.source ? <span className={`chip ${it.source === 'STRAVA' ? 'chip-accent' : ''}`}>{it.source}</span> : null}</article>;
+      return <article className="card" key={it.id}><strong>{interpolate(appSpec.templates.stravaCandidateCard.title, { ...ctx, item: it })}</strong></article>;
+    })}</div>;
+  }
+
+  return <div>Unsupported component {component.type}{index}</div>;
+}
+
+export function filterTimeline(items: any[], selected: string, map: Record<string, string>) {
+  const target = map[selected];
+  if (!target || target === '*') return items;
+  return items.filter((i) => i.type === target);
+}
diff --git a/src/components/SpecGate.tsx b/src/components/SpecGate.tsx
new file mode 100644
index 0000000..2911c2f
--- /dev/null
+++ b/src/components/SpecGate.tsx
@@ -0,0 +1,10 @@
+'use client';
+import ScreenRenderer from './ScreenRenderer';
+import { validatedSpec } from '@/lib/spec';
+
+export default function SpecGate({ screenId, routeParams = {} }: { screenId: string; routeParams?: Record<string, string> }) {
+  if (!validatedSpec.ok) {
+    return <main className="page"><h1>Spec validation error</h1><pre>{validatedSpec.errors.join('\n')}</pre></main>;
+  }
+  return <ScreenRenderer screenId={screenId} routeParams={routeParams} />;
+}
diff --git a/src/lib/actions.ts b/src/lib/actions.ts
new file mode 100644
index 0000000..5843fa0
--- /dev/null
+++ b/src/lib/actions.ts
@@ -0,0 +1,18 @@
+import { buildPath } from './path';
+import { getValueByPath } from './paths';
+
+export function selectAthleteByRouteParam(collection: any[], athleteId: string) {
+  return collection.find((a) => a.id === athleteId);
+}
+
+export function mutatePrepend(arr: any[], item: any) {
+  return [item, ...arr];
+}
+
+export function conditionalNavigate(flag: boolean, to: string, elseTo: string, params: Record<string, string>) {
+  return buildPath(flag ? to : elseTo, params);
+}
+
+export function safeInterpolate(tpl: string, ctx: any) {
+  return tpl.replace(/{{\s*([^}]+)\s*}}/g, (_, expr) => String(getValueByPath(ctx, expr.trim()) ?? ''));
+}
diff --git a/src/lib/interpolate.ts b/src/lib/interpolate.ts
new file mode 100644
index 0000000..fc54673
--- /dev/null
+++ b/src/lib/interpolate.ts
@@ -0,0 +1,18 @@
+import { getValueByPath } from './paths';
+
+const warned = new Set<string>();
+
+export function interpolate(template: any, ctx: Record<string, any>) {
+  if (typeof template !== 'string') return template;
+  return template.replace(/{{\s*([^}]+)\s*}}/g, (_, expr) => {
+    const value = getValueByPath(ctx, expr.trim());
+    if (value === undefined || value === null) {
+      if (process.env.NODE_ENV !== 'production' && !warned.has(expr)) {
+        warned.add(expr);
+        console.warn(`Missing interpolation path: ${expr}`);
+      }
+      return '';
+    }
+    return String(value);
+  });
+}
diff --git a/src/lib/path.ts b/src/lib/path.ts
new file mode 100644
index 0000000..327d829
--- /dev/null
+++ b/src/lib/path.ts
@@ -0,0 +1,8 @@
+import { appSpec } from './spec';
+
+export function buildPath(screenId: string, params: Record<string, string> = {}) {
+  const screen = appSpec.screens.find((s) => s.id === screenId);
+  if (!screen) return '/';
+  const route = screen.route.replace(/:([A-Za-z0-9_]+)/g, (_, key) => params[key] ?? '');
+  return `/${route}`;
+}
diff --git a/src/lib/paths.ts b/src/lib/paths.ts
new file mode 100644
index 0000000..771887a
--- /dev/null
+++ b/src/lib/paths.ts
@@ -0,0 +1,14 @@
+export function getValueByPath(obj: any, path: string) {
+  return path.split('.').reduce((acc, key) => (acc == null ? undefined : acc[key]), obj);
+}
+
+export function setValueByPath(obj: any, path: string, value: any) {
+  const keys = path.split('.');
+  let cur = obj;
+  for (let i = 0; i < keys.length - 1; i += 1) {
+    const key = keys[i];
+    if (cur[key] == null || typeof cur[key] !== 'object') cur[key] = {};
+    cur = cur[key];
+  }
+  cur[keys[keys.length - 1]] = value;
+}
diff --git a/src/lib/spec.ts b/src/lib/spec.ts
new file mode 100644
index 0000000..df52938
--- /dev/null
+++ b/src/lib/spec.ts
@@ -0,0 +1,35 @@
+import rawSpec from '../../spec/appSpec.json';
+
+export type AnyObj = Record<string, any>;
+export type AppSpec = {
+  app: AnyObj;
+  state: AnyObj;
+  routes: AnyObj;
+  screens: { id: string; route: string; components: AnyObj[]; onEnter?: AnyObj[]; visibility?: { roles?: string[] } }[];
+  templates: AnyObj;
+  mockData: AnyObj;
+  mockTemplates: AnyObj;
+};
+
+export const appSpec: AppSpec = rawSpec as AppSpec;
+
+export function validateSpec(input: unknown): { ok: true; spec: AppSpec } | { ok: false; errors: string[] } {
+  const errors: string[] = [];
+  const obj = input as AnyObj;
+  for (const k of ['app', 'state', 'routes', 'screens', 'templates', 'mockData', 'mockTemplates']) {
+    if (!(k in (obj || {}))) errors.push(`Missing required key: ${k}`);
+  }
+  if (!Array.isArray(obj?.screens)) {
+    errors.push('screens must be an array');
+  } else {
+    obj.screens.forEach((screen: AnyObj, i: number) => {
+      for (const key of ['id', 'route', 'components']) {
+        if (!(key in (screen || {}))) errors.push(`screens[${i}] missing key: ${key}`);
+      }
+    });
+  }
+  if (errors.length) return { ok: false, errors };
+  return { ok: true, spec: obj as AppSpec };
+}
+
+export const validatedSpec = validateSpec(appSpec);
diff --git a/src/lib/store.ts b/src/lib/store.ts
new file mode 100644
index 0000000..f15b4d3
--- /dev/null
+++ b/src/lib/store.ts
@@ -0,0 +1,72 @@
+'use client';
+
+import { create } from 'zustand';
+import { appSpec } from './spec';
+import { getValueByPath, setValueByPath } from './paths';
+
+export type RootState = {
+  state: any;
+  mockData: any;
+  mockTemplates: any;
+  controls: Record<string, string>;
+  form: Record<string, any>;
+  persistEnabled: boolean;
+  initPersistence: () => void;
+  getByPath: (path: string) => any;
+  setByPath: (path: string, value: any) => void;
+  setControl: (id: string, value: string) => void;
+  setFormValue: (id: string, value: any) => void;
+  mutateMock: (targetPath: string, operation: 'prepend' | 'prependMany', payload: any) => void;
+};
+
+const baseState = {
+  state: structuredClone(appSpec.state),
+  mockData: structuredClone(appSpec.mockData),
+  mockTemplates: structuredClone(appSpec.mockTemplates),
+  controls: {},
+  form: {},
+  persistEnabled: false
+};
+
+export const useAppStore = create<RootState>((set, get) => ({
+  ...baseState,
+  initPersistence: () => {
+    if (typeof window === 'undefined') return;
+    const enabled = new URLSearchParams(window.location.search).get('persist') === '1';
+    set({ persistEnabled: enabled });
+    if (!enabled) return;
+    const raw = localStorage.getItem('sosg-store-v1');
+    if (raw) {
+      try {
+        const parsed = JSON.parse(raw);
+        set({ state: parsed.state ?? get().state, mockData: parsed.mockData ?? get().mockData });
+      } catch {}
+    }
+    useAppStore.subscribe((s) => {
+      localStorage.setItem('sosg-store-v1', JSON.stringify({ state: s.state, mockData: s.mockData }));
+    });
+  },
+  getByPath: (path) => getValueByPath(get(), path),
+  setByPath: (path, value) => {
+    set((current) => {
+      const next = structuredClone(current);
+      setValueByPath(next, path, value);
+      return next;
+    });
+  },
+  setControl: (id, value) => set((s) => ({ controls: { ...s.controls, [id]: value } })),
+  setFormValue: (id, value) => set((s) => ({ form: { ...s.form, [id]: value } })),
+  mutateMock: (targetPath, operation, payload) => {
+    set((current) => {
+      const next = structuredClone(current);
+      const arr = getValueByPath(next, targetPath) ?? [];
+      if (operation === 'prepend') arr.unshift(payload);
+      if (operation === 'prependMany') arr.unshift(...payload);
+      setValueByPath(next, targetPath, arr);
+      const selected = next.mockData.selectedAthlete;
+      const full = next.mockData.athletesFull.map((a: any) => (a.id === selected.id ? selected : a));
+      next.mockData.athletesFull = full;
+      return next;
+    });
+  }
+}));
diff --git a/src/styles/tokens.css b/src/styles/tokens.css
new file mode 100644
index 0000000..8acf702
--- /dev/null
+++ b/src/styles/tokens.css
@@ -0,0 +1,13 @@
+:root {
+  --font-sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
+  --text-title: 24px; --text-title-weight: 600; --text-title-line: 1.2;
+  --text-h2: 18px; --text-h2-weight: 600; --text-h2-line: 1.3;
+  --text-body: 16px; --text-body-weight: 400; --text-body-line: 1.5;
+  --text-meta: 12px; --text-meta-weight: 500; --text-meta-line: 1.3;
+  --space-1: 4px; --space-2: 8px; --space-3: 12px; --space-4: 16px; --space-5: 20px; --space-6: 24px;
+  --radius-sm: 10px; --radius-md: 14px; --radius-lg: 18px;
+  --border: 1px solid rgba(0,0,0,0.08);
+  --shadow-sm: 0 1px 2px rgba(0,0,0,0.06); --shadow-md: 0 6px 20px rgba(0,0,0,0.08);
+  --bg: #F7F7F8; --surface: #FFFFFF; --text: #111827; --muted: #6B7280; --border-color: rgba(0,0,0,0.08);
+  --accent: #0EA5A4; --accent-contrast: #FFFFFF; --milestone-bg: rgba(245, 158, 11, 0.12);
+}
diff --git a/tests/e2e/sosg.spec.ts b/tests/e2e/sosg.spec.ts
new file mode 100644
index 0000000..8ab146f
--- /dev/null
+++ b/tests/e2e/sosg.spec.ts
@@ -0,0 +1,53 @@
+import { expect, test } from '@playwright/test';
+
+async function login(page: any, role: string) {
+  await page.goto('/login');
+  await page.getByTestId('select-role_selector').selectOption(role);
+  await page.getByTestId('btn-btn_login').click();
+  await expect(page).toHaveURL(/\/athlete_list$/);
+}
+
+test('E2E-1 Volunteer -> list -> Daniel -> cues visible', async ({ page }) => {
+  await login(page, 'VOLUNTEER');
+  await page.getByTestId('athlete-card-a1').click();
+  await expect(page).toHaveURL(/\/athlete_timeline\/a1$/);
+  await expect(page.getByTestId('card-card_cues_pinned')).toContainText('Countdown cues');
+});
+
+test('E2E-2 Parent role gating', async ({ page }) => {
+  await login(page, 'PARENT');
+  await page.getByTestId('athlete-card-a1').click();
+  await expect(page.getByTestId('btn-btn_add_note')).toHaveCount(0);
+  await expect(page.getByTestId('btn-btn_import_strava')).toHaveCount(0);
+});
+
+test('E2E-3 Add coach note', async ({ page }) => {
+  await login(page, 'VOLUNTEER');
+  await page.getByTestId('athlete-card-a1').click();
+  await page.getByTestId('btn-btn_add_note').click();
+  await page.getByTestId('input-went_well').fill('Steady pace');
+  await page.getByTestId('input-was_hard').fill('Tired at 20');
+  await page.getByTestId('input-next_time').fill('Water at 15');
+  await page.getByTestId('btn-btn_save_note').click();
+  await expect(page.getByTestId('timeline-item-0')).toContainText('Coach note');
+});
+
+test('E2E-4 Strava connect + import', async ({ page }) => {
+  await login(page, 'VOLUNTEER');
+  await page.getByTestId('athlete-card-a1').click();
+  await page.getByTestId('btn-btn_import_strava').click();
+  await expect(page).toHaveURL(/\/strava_connect\/a1$/);
+  await page.getByTestId('btn-btn_simulate_strava_connect').click();
+  await expect(page).toHaveURL(/\/strava_import_review\/a1$/);
+  await expect(page.getByTestId('list-candidate_activities')).toBeVisible();
+  await page.getByTestId('btn-btn_import_selected').click();
+  await expect(page).toHaveURL(/\/athlete_timeline\/a1$/);
+  await expect(page.getByTestId('timeline-item-0')).toContainText('STRAVA');
+});
+
+test('E2E-5 Empty state', async ({ page }) => {
+  await login(page, 'VOLUNTEER');
+  await page.getByTestId('athlete-card-a2').click();
+  await expect(page).toHaveURL(/\/athlete_timeline\/a2$/);
+  await expect(page.getByText('No entries yet')).toBeVisible();
+});
diff --git a/tests/unit/actions.spec.ts b/tests/unit/actions.spec.ts
new file mode 100644
index 0000000..160ab2a
--- /dev/null
+++ b/tests/unit/actions.spec.ts
@@ -0,0 +1,29 @@
+import { appSpec } from '@/lib/spec';
+import { buildPath } from '@/lib/path';
+import { conditionalNavigate, mutatePrepend, safeInterpolate, selectAthleteByRouteParam } from '@/lib/actions';
+import { filterTimeline } from '@/components/ScreenRenderer';
+
+test('Unit-1 selectAthleteByRouteParam selects correct athlete', () => {
+  expect(selectAthleteByRouteParam(appSpec.mockData.athletesFull, 'a1')?.name).toBe('Daniel');
+});
+
+test('Unit-2 mutateMock.prepend adds item at index 0', () => {
+  expect(mutatePrepend([{ id: 2 }], { id: 1 })[0]).toEqual({ id: 1 });
+});
+
+test('Unit-3 filterBinding filters timeline by type', () => {
+  const items = [{ type: 'session' }, { type: 'note' }];
+  expect(filterTimeline(items, 'Notes', { Notes: 'note', All: '*' })).toEqual([{ type: 'note' }]);
+});
+
+test('Unit-4 conditionalNavigate chooses elseTo when false', () => {
+  expect(conditionalNavigate(false, 'profile', 'login', {})).toBe('/login');
+});
+
+test('Unit-5 interpolation missing path returns "" and does not throw', () => {
+  expect(safeInterpolate('x {{state.none}}', { state: {} })).toBe('x ');
+});
+
+test('Unit-6 buildPath constructs correct URL', () => {
+  expect(buildPath('athlete_timeline', { athleteId: 'a1' })).toBe('/athlete_timeline/a1');
+});
diff --git a/tsconfig.json b/tsconfig.json
new file mode 100644
index 0000000..f3af7d6
--- /dev/null
+++ b/tsconfig.json
@@ -0,0 +1,24 @@
+{
+  "compilerOptions": {
+    "target": "ES2020",
+    "lib": ["dom", "dom.iterable", "esnext"],
+    "allowJs": false,
+    "skipLibCheck": true,
+    "strict": true,
+    "noEmit": true,
+    "esModuleInterop": true,
+    "module": "esnext",
+    "moduleResolution": "bundler",
+    "resolveJsonModule": true,
+    "isolatedModules": true,
+    "jsx": "preserve",
+    "incremental": true,
+    "plugins": [{ "name": "next" }],
+    "baseUrl": ".",
+    "paths": {
+      "@/*": ["src/*"]
+    }
+  },
+  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
+  "exclude": ["node_modules"]
+}
